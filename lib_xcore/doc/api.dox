Usage
-----

All functions can be accessed via the ``xcore_c.h`` header::

  #include "xcore_c.h"

You will also have to add ``lib_xcore_c`` to the ``USED_MODULES`` field of
your application Makefile.

Using timers
............

/** \file api/xcore/hwtimer.h
  The library provides support for xCORE hardware timers. They are allocated
  using: \code
    hwtimer_t tmr = hwtimer_alloc();
  \endcode

  A timer can then be read to get the current time by doing: \code
    uint32_t time = hwtimer_get_time(tmr);
  \endcode

  There are two functions provided to delay using a timer. The first waits for a
  specified time: \code
    // The times are in 10ns, so 100000 timer ticks is 1ms
    uint32_t now = hwtimer_wait_until(tmr, time + 100000); // Wait for (time + 1ms)
  \endcode

  The second delays for a period of time in 100MHz timer ticks: \code
    hwtimer_delay(tmr, 100000); // Delay for 1ms
  \endcode

  When the timer is no longer required it can be released to be used by other cores
  by calling: \code
    hwtimer_free(tmr);
  \endcode

  Each logical core is automatically allocated a hardware timer for use by xC code.
  If a task is not running xC code, or the xC code is not using timers, the
  core's hardware timer may be released back into the pool by calling: \code
    // Start of task.
    hwtimer_free_xc_timer();
    // ...
    hwtimer_realloc_xc_timer();
    // End of task.
  \endcode

  As the above code illustrates, the hardware timer must be reallocated before the logical
  core completes execution.
  \attention There must be a free hardware timer available when hwtimer_realloc_xc_timer() is called.
*/

Using channels
..............

/** \file api/xcore/channel.h

  \section local-channels Local channels

  Local channel connections on a tile are fully supported by the library. A channel
  connection is created using: \code
    channel_t c = chan_alloc(c);
  \endcode

  Data can then be sent and received using: \code
    chan_out_word(c.end_a, 1);
    chan_out_byte(c.end_a, 2);
  \endcode

  with a corresponding block of code on another core to consume the data: \code
    uint32_t i = chan_in_word(c.end_b);
    uint8_t j = chan_in_byte(c.end_b);
  \endcode

  When the channel is finished with then it is closed and the resources released
  using: \code
    chan_free(c);
  \endcode

  \section intertile-channels Inter-tile channels
  
  The use of inter-tile channels is supported by the library. However, the only way
  to create inter-tile channels is to use a top-level main() written in xC. Without
  the top-level main there is no way to automatically communicate the tile ID of
  multiple tiles within a system.

  A basic top-level main would look like: \code
    #include <platform.h>
    #include "application.h"

    int main()
    {
      chan c;
      par {
        on tile[0]: {
          application_0(c);
        }
        on tile[1]: {
          application_1(c);
        }
      }
      return 0;
    }
  \endcode

  This uses xC to do all of the thread assignment and connecting of the initial
  channel. After that, the applications can use more channels on each tile and
  have enough information to know how to connect to each other.

  A new channel-end can be allocated using: \code
    void application_0(chanend c)
    {
      chanend new_c = chanend_alloc();
  \endcode

  And a new connection established by passing this new channel-end over the
  existing link, receiving the destination link on the other tile and connecting
  the two. So, both applications can do: \code
      chan_out_word(c, new_c);  // Send my new-chanend to other tile.
      chanend new_dest = (chanend)chan_in_word(c);  // Recieve other tile's new-chanend...
      chanend_set_dest(new_c, new_dest);  // ... and connect it to my new-chanend.
  \endcode

  When the channel-end is finished with then it is closed and the resources released
  using: \code
    chanend_free(new_c);
  \endcode
*/

Streaming Channels
~~~~~~~~~~~~~~~~~~

/** \file api/xcore/channel_streaming.h

  Streaming channels can be used in a similar manner to standard channels. A
  streaming channel is created using: \code
    streaming_channel_t c = s_chan_alloc(c);
  \endcode

  Data can then be sent and received using: \code
    s_chan_out_word(c.end_a, 1);
    s_chan_out_byte(c.end_a, 2);
  \endcode

  with a corresponding block of code on another core to consume the data: \code
    uint32_t i = s_chan_in_word(c.end_b);
    uint8_t j = s_chan_in_byte(c.end_b);
  \endcode

  When the channel is finished with then it is closed and the resources released
  using: \code
    s_chan_free(c);
  \endcode

*/

Channel transactions
~~~~~~~~~~~~~~~~~~~~

/** \file api/xcore/channel_streaming.h

  The library has functions to support interacting with xC channel ends. This
  includes \c master / \c slave transactions. For example, a block of xC could use a
  \c master transaction to send a block of words syhchronised only at the beginning
  and end: \code
    uint32_t data[10] = {...}
    master {
      for (size_t i = 0; i < 10; i++) {
        c <: data[i];
      }
    }
  \endcode

  The C code to receive this data is of the form: \code
    // we have a chanend 'c';
    transacting_chanend_t tc = chan_init_transaction_slave(c);
    uint32_t data[10];
    for (size_t i = 0; i < 10; i++) {
      data[i] = t_chan_in_word(tc);
    }
    (void)chan_complete_transaction(tc);  //returns our original chanend
  \endcode

  There are additional functions to send and receive both bytes and blocks of data.

*/

Using ports and clock blocks
............................

/** \file api/xcore/clock.h

  The use of ports and clock blocks is fully supported in the library. This section
  of the document gives a brief example of how to use the library. For complete
  documentation of the functionality supported please see the API section.

  \b Example

  This example will show how to use the library to configure a clock block and
  port. The first thing to do is to configure the clock block. For example, if using
  clock block 1 to be clocked from a divided version of the reference clock: \code
    clock_id_t c = clock_1;
    clock_enable(c);
    clock_set_source_clk_ref(c);
    clock_set_divide(c, 1);  // Configure to 50MHz (100Mhz / 2*1)
  \endcode

  The port to be used can then be enabled, configured and connected to the clock: \code
    port_id_t p = port_1A;
    port_enable(p);
    port_set_clock(p, c);
  \endcode

  Starting the clock will reset the port counters on all connected ports. This is
  generally best done after all ports have been connected so that their counters
  will be synchronised: \code
    clock_start(c);
  \endcode

  The port can now be used to output or input data: \code
    port_out(p, 1);
    port_out(p, 0);
    // ...
  \endcode

  In order to clean up, both the port and clock block must be disabled: \code
    clock_disable(c);
    port_disable(p);
  \endcode

  \todo TODO: example of driving clock from input port

  \todo Driving clock

*/

Ready signals
~~~~~~~~~~~~~

/** \file api/xcore/port_protocol.h

  Configuring ports to use ready signals is done using the \c port_protocol_*
  functions provided in \ref port_protocol.h . All the basic functions needed to
  implement this functionality is provided, but the order of configuring a port
  as a strobed or handshaken port is critical and therefore best done using these
  wrapper functions.

  For example, to create a data port which is controlled by a strobe then the
  following code sequence could be used: \code
    port p = port_4A
    port_enable(p);
    port p_ready = port_1A;
    port_enable(p_ready);
    clock clk = clock_1;
    clock_enable(clk);

    port_protocol_in_strobed_slave(p, p_ready, clk);
    clock_start(clk);
  \endcode

  After this, any data received on the port \c p will only be available when the
  valid signal (strobe on \c PORT_1A ) is high.

*/

Using hardware locks
....................

/** \file api/xcore/lock.h

  The library provides support for xCORE hardware locks. They are allocated
  using: \code
    lock_t l = lock_alloc();
  \endcode

  To enter a mutex region the lock is then acquired:m \code
    lock_acquire(l);
  \endcode

  After this function completes it is safe to use shared state that must only be
  used by one core at a time.

  To leave the mutex region the lock is released: \code
    lock_release(l);
  \endcode

  The lock resource is released using: \code
    lock_free(l);
  \endcode

*/

Using interrupts
................

/** \file api/xcore/interrup_wrappers.h

The library provides support for hardware interrupts from xCORE resources.

Interrupts can be raised by resources as an alternative to select events, and
will be vectored to the provided callback function.

As interrupts can occur at any point during program execution there are certain
requirements which must be adhered to ensure safe operation:

  #. Resources must not have interrupts enabled whilst being configured, or
     the core must have interrupts masked if the resource has already been
     configured to raise interrupts.

  #. The core must have interrupts masked when disabling interrupts for a
     resource.

\b Example
~~~~~~~

As an example, take a function which receives data from two channels and handles
whichever one is ready.

We start by declaring the scope in which interrupts may occur - 'the hosting function'.
The hosting function will make space on its stack for a temporary kernel stack which
will be used by the interrupts.
Our ordinary <tt>void test(chanend,chanend)</tt> is turned into a hosting function by
wrapping it in the \c DECLARE_INTERRUPT_PERMITTED function macro: \code

  // xc top level file creating our logical cores.
  DECLARE_INTERRUPT_PERMITTED(void, test, chanend c1, chanend c2);
  int main() {
    chan c, d;
    par {
      INTERRUPT_PERMITTED(test)(c, d); // interrupts hosted on this core.

      // Start two other cores to create the interrupt events.
      {
        delay_ticks(5000);
        c <: 12;
        delay_ticks(5000);
        c <: 34;
      }
      {
        delay_ticks(10000);
        d <: 56;
        delay_ticks(10000);
        d <: 78;
      }
    }
    return 0;
  }
\endcode

and likewise the definition (see below for implementation): \code
  DEFINE_INTERRUPT_PERMITTED(my_group, void, test, chanend c1, chanend c2)
  {
    ...
  }
\endcode

The identifier \c my_group tells the hosting function which interrupts it will
be hosting, so it can calculate the stack requirements.

One piece of user data will be sent to the callback as a \c void* argument.
We will register a pointer to a structure: \code
  typedef struct {
    chanend c;    // The resource that caused the interrupt.
    const char *message;
  } chan_data_t;
\endcode

We now define/declare the interrupt callback function, wrapping it in function
macros and placing it in the same group: \code
  volatile size_t received = 0;  // For the host to monitor events.

  DEFINE_INTERRUPT_CALLBACK(my_group, my_handler, data)
  {
    chan_data_t *cd = (chan_data_t*)data;
    uint32_t x;
    chan_in_word(cd->c, &x);
    debug_printf("%s received %d\n", cd->message, x);
    received++;
  }
\endcode

And finally we can set up the interrupt and enable them: \code
  DEFINE_INTERRUPT_PERMITTED(my_group, void, test, chanend c1, chanend c2)
  {
    // Set up interrupt.
    // We assume either the triggers are disabled or interrupts are masked.
    chan_data_t cd1 = {c1, "channel 1"};
    chanend_setup_interrupt_callback(cd1.c, (void*)&cd1,
                                     INTERRUPT_CALLBACK(my_handler));
    chan_data_t cd2 = {c2, "channel 2"};
    chanend_setup_interrupt_callback(cd2.c, (void*)&cd2,
                                     INTERRUPT_CALLBACK(my_handler));
    // Enable interrupts.
    chanend_enable_trigger(cd1.c);
    chanend_enable_trigger(cd2.c);
    interrupt_unmask_all();
\endcode

And when we have finished, disable them: \code
    while (received < 4);

    // Disable interrupts.
    interrupt_mask_all(); // Mask before disabling.
    chanend_disable_trigger(cd1.c);
    chanend_disable_trigger(cd2.c);
  }
\endcode

